#  EJ

这是一个用C++编写的json类库,用于构建以及解析json文件,并提供简洁的API用来访问数据.

## 文档目录

* [许可证](#许可证)
* [使用](#使用)
  * [EJ介绍](#EJ介绍)
  * [举例](#举例)
    * [构建](#构建)
    * [解析](#解析)
    * [打印](#打印)
    * [删除](#删除)
    * [访问数据](#访问数据)
  * [注意事项](#注意事项)

## 许可证
>EJ-许可协议
>
>Copyright (c) 2018 Jiaminwei
>
>1.序言:本协议用于管辖用户及商业实体 (以下简称：被许可人) 和软件原作者（以下简称：许可方）之间
  的关系。使用本软件（包括但不限于复制、下载、安装、运行本软件）即视为同意本协议。本协议规定了
  使用许可方创建和拥有的EJ (以下简称本软件) 的条款、权利、限制和义务，详情如下:
>
>2.许可证授予:许可方特此授予被许可人个人复制、分发、修改以及非商业性使用本软件的权利(商业使用请
  联系软件原作者)。
>
>3.被许可人义务:  
  3.1在延伸的代码中（修改和由本软件的源代码衍生的代码中）必须包含原代码中的协议与声明。  
	3.2.若被许可人修改了代码，则必须在被修改的文件中作出相应说明。
>
>4.受限:禁止被许可人以商业或盈利为目的使用本软件或其衍生作品（包括但不限于修改本软件、以本软件为
  基础进行二次开发、调用本软件所定义的接口等）。
>
>5.终止:  
  5.1若被许可人有违本协议任一条款即自动终止许可。  
	5.2.许可方有权终止本协议及对被许可人的许可。
>
>6.免责条款:在法律允许的范围内，软件是根据原样提供的。许可方不应对因本软件的操作、故障、bug或本软
  件与被许可方的最终设备之间的任何其他交互而招致的任何损害、费用、任何其他付款承担责任，此外，在
  依赖本软件或使用本软件的源代码时， 许可方不应对被许可方编写的源代码中的任何缺陷负责。
>
>7.保留权利：许可方有权修改本协议条款（若被许可人不认同修改后的协议条款，可停止使用本软件，继续使
  用即代表同意修改后的协议条款），并对本协议未尽事宜保留所有权利。
## 使用

### EJ介绍

EJ是一个轻量级的json类库(一个头文件和一个源码文件,编译后即可使用),有助于程序员快速构建或解析json文件.EJ没有花里胡哨的功能,仅提供构建和解析以及访问和打印等核心功能,依据二八原则,这些代码足以应对80%的使用场景,后续将视情况酌情添加新的功能.作者会持续提供代码的优化与维护.


### 举例

```
{
  "name": "金庸",
  "foreign-language name": "Louis Cha",
  "nationality": "中国",
  "nation": "汉族",
  "birthplace": [
    { "province": "浙江" },
    { "city": "海宁" }
  ],
  "profession": [ "作家", "政论家", "社会活动家" ],
  "works": [ "射雕英雄传", "天龙八部", "倚天屠龙记" ]
}
```

假设要处理的json文件如上所示.



#### 构建

```
	EJ newjson;
	clock_t start, ends;

	//构建测试
	Node &ob = newjson.AddObject();
	ob.AddKeyvalue("name", "金庸");
	ob.AddKeyvalue("foreign-language name", "Louis Cha");
	ob.AddKeyvalue("nationality", "中国");
	ob.AddKeyvalue("nation", "汉族");

	Node &ar0 = ob.AddArray("birthplace");
	ar0.AddObject().AddKeyvalue("province", "浙江");
	ar0.AddObject().AddKeyvalue("city", "嘉兴");

	Node &ar2 = ob.AddArray("profession");
	ar2.AddValue("作家");
	ar2.AddValue("政论家");
	ar2.AddValue("社会活动家");

	Node &ar3 = ob.AddArray("works");
	ar3.AddValue("射雕英雄传");
	ar3.AddValue("神雕侠侣");
	ar3.AddValue("倚天屠龙记");
```

EJ对象加[]用来返回json结构首节点的子节点的引用.

Node对象加[]用来返回当前节点子节点的引用.

[]中的字符串用于访问带键名称的子节点,数字用于访问无键名称的子节点(从0开始).



#### 解析

```
newjson.EJParse(s);			//调用字符串解析方法
newjson.EJParse(filePath);	//调用文件解析方法
```

直接用EJ对象调用EJParse方法,传入要解析的字符串或文件,解析后的json结构挂载在EJ对象的root成员变量上,可通过EJ对象访问整个json结构.



#### 打印

```
string EJPrint();				//打印json结构,输出字符串
```

用EJ对象调用EJPrint方法,将打印对象下所挂载的json结构,返回字符串.



#### 删除

```
void DeleteEJ();		//删除整个结构
```

用EJ对象调用DeleteEJ方法,将删除对象下所挂载的json结构.



#### 访问数据

```
//数据接口测试
ar0[1]["city"].value_str = "海宁";
ar3[2].value_str = "天龙八部";
```

获得需要操作的节点的引用后,访问成员变量,可进行读取或赋值操作.



### 注意事项

* 打印方法返回的是未经格式化的字符串.
* 暂未对json结构嵌套深度做限制,使用时请注意堆区和栈区溢出问题.